var T=Object.defineProperty;var v=(A,t,e)=>t in A?T(A,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):A[t]=e;var o=(A,t,e)=>v(A,typeof t!="symbol"?t+"":t,e);const O=Math.PI,p=2*O;function a(A){return A*(Math.PI/180)}function M(A){return A*(180/Math.PI)}function B(A){return(A%p+p)%p}class z{constructor(t,e){o(this,"x");o(this,"z");this.x=t,this.z=e}static fromArray(t){if(t.length!==2)throw new Error(`${this.constructor.name} Array must contain exactly two elements: [x, z]`);return new z(t[0],t[1])}static fromObject(t){if(typeof t.x!="number"||typeof t.z!="number")throw new Error(`${this.constructor.name} Object must have numeric properties x and z`);return new z(t.x,t.z)}toPoint(){return new c(this.z,this.x/2)}toString(){return`X${this.x} Z${this.z}`}}class c{constructor(t,e){o(this,"x");o(this,"y");this.x=t,this.y=e}static fromArray(t){if(t.length!==2)throw new Error(`${this.constructor.name} Array must contain exactly two elements: [x, y]`);return new c(t[0],t[1])}static fromArrayXZ(t){if(t.length!==2)throw new Error(`${this.constructor.name} Array must contain exactly two elements: [x, z]`);return new c(t[1],t[0]/2)}static fromObject(t){if(typeof t.x!="number"||typeof t.y!="number")throw new Error(`${this.constructor.name} Object must have numeric properties x and y`);return new c(t.x,t.y)}static fromObjectXZ(t){if(typeof t.x!="number"||typeof t.z!="number")throw new Error(`${this.constructor.name} Object must have numeric properties x and z`);return new c(t.z,t.x/2)}isZero(){return this.x===0&&this.y===0}toVector(t=new c(0,0)){return t.isZero()?new w(this.x,this.y):new w(t.x-this.x,t.y-this.y)}toObjectXZ(){return{x:this.y*2,z:this.x}}toObject(){return{x:this.x,y:this.y}}toArray(){return[this.x,this.y]}toPointXZ(){return z.fromObject(this.toObjectXZ())}add(t){return new c(this.x+t.x,this.y+t.y)}subtract(t){return new c(this.x-t.x,this.y-t.y)}multiply(t){return new c(this.x*t,this.y*t)}divide(t){if(t===0)throw new Error(`${this.constructor.name} - Division by zero`);return new c(this.x/t,this.y/t)}clone(){return new c(this.x,this.y)}equals(t){return this.x===t.x&&this.y===t.y}distanceTo(t){return this.toVector(t).length()}}class w extends c{constructor(t,e){super(t,e)}static fromPoints(t,e){return new w(e.x-t.x,e.y-t.y)}length(){return Math.sqrt(this.x**2+this.y**2)}normalize(){const t=this.length();if(t===0)throw new Error(`${this.constructor.name} - Cannot normalize a zero vector`);return new w(this.x/t,this.y/t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}angleTo(t){const e=this.dot(t),s=this.length()*t.length();if(s===0)throw new Error(`${this.constructor.name} - Cannot calculate angle with zero-length vector`);const n=e/s;return Math.acos(Math.min(Math.max(n,-1),1))}rotate(t){const e=Math.cos(t),s=Math.sin(t),n=this.x*e-this.y*s,r=this.x*s+this.y*e;return new w(n,r)}projectOnto(t){const e=this.dot(t)/t.length()**2;return t.multiply(e)}lerp(t,e){const s=this.x+e*(t.x-this.x),n=this.y+e*(t.y-this.y);return new w(s,n)}distanceTo(t){return Math.sqrt((this.x-t.x)**2+(this.y-t.y)**2)}isZero(){return this.x===0&&this.y===0}reflect(t){const e=this.dot(t);return this.subtract(t.multiply(2*e))}angleDirection(t){const e=this.cross(t);return e>0?1:e<0?-1:0}bisector(t){return this.add(t).normalize()}clampLength(t){return this.length()>t?this.normalize().multiply(t):this}negate(){return new w(-this.x,-this.y)}isParallelTo(t){return this.cross(t)===0}translate(t){return this.add(t)}increaseLength(t){const e=this.length();if(e===0)throw new Error(`${this.constructor.name} - Cannot increase length of a zero vector`);const s=(e+t)/e;return this.multiply(s)}decreaseLength(t){const e=this.length();if(t>=e)return new w(0,0);const s=(e-t)/e;return this.multiply(s)}angleRad(){return Math.atan2(this.y,this.x)}angle(){return M(Math.atan2(this.y,this.x))}arrowDirection(){return this.angleRad()===Math.PI/2?"↑":this.angleRad()===3*Math.PI/2?"↓":this.angleRad()===0?"→":this.angleRad()===Math.PI?"←":this.x>0&&this.y<0?"↘":this.x<0&&this.y<0?"↙":this.x>0&&this.y>0?"↗":this.x<0&&this.y>0?"↖":"null"}clone(){return new w(this.x,this.y)}equals(t){return super.equals(t)}add(t){return super.add(t).toVector()}subtract(t){return super.subtract(t).toVector()}multiply(t){return super.multiply(t).toVector()}divide(t){return super.divide(t).toVector()}}class u{constructor(t,e){o(this,"start");o(this,"end");o(this,"length");o(this,"angle");o(this,"angleRad");o(this,"vector");o(this,"delta");o(this,"arrowDirection");this.start=t,this.end=e,this.vector=this.toVector(),this.delta=w.fromPoints(e,t),this.length=this.vector.length(),this.angle=this.vector.angle(),this.angleRad=this.vector.angleRad(),this.arrowDirection=this.vector.arrowDirection()}static fromArray(t){if(t.length!==2)throw new Error(`${this.constructor.name} 数组必须包含两个点坐标`);const[e,s]=t;return new u(c.fromArray(e),c.fromArray(s))}static fromArrayXZ(t){if(t.length!==2)throw new Error(`${this.constructor.name} 数组必须包含两个点坐标`);const[e,s]=t;return new u(c.fromArrayXZ(e),c.fromArrayXZ(s))}static fromNumber(t,e,s,n){return u.fromArray([[t,e],[s,n]])}static fromNumberXZ(t,e,s,n){return u.fromArray([[e,t/2],[n,s/2]])}static createLineFromAngle(t,e,s){if([...t.toArray(),...e.toArray(),s].filter(isFinite).length<4||!isFinite(s))throw new Error(`${this.constructor.name} 有效参数不够，无法进行计算。`);const i=Math.tan(a(s));return isFinite(t.x)?isFinite(t.y)?isFinite(e.x)?isFinite(e.y)||(e.y=t.y+(e.x-t.x)*i):e.x=t.x+(e.y-t.y)/i:t.y=e.y-(e.x-t.x)*i:t.x=e.x-(e.y-t.y)/i,new u(t,e)}static createLineFromLengthAndAngle(t,e,s){const n=a(s),r=new w(Math.cos(n),Math.sin(n)),i=t.add(r.multiply(e*(s>0&&s<180?-1:1)));return new u(t,i)}static createHorizontallLine(t,e){return new u(t,new c(t.x,e))}static createVerticalLine(t,e){return new u(t,new c(e,t.y))}static createHorizontallLineXZ(t,e){return new u(t.toPoint(),new z(e,t.z).toPoint())}static createVerticalLineXZ(t,e){return new u(t.toPoint(),new z(t.x,e).toPoint())}reverse(){return new u(this.end,this.start)}static createFillet(t,e,s,n){const r=new u(t,e),i=new u(e,s);if(r.length<n||i.length<n)throw new Error(`${this.constructor.name} 长度不够，无法进行倒角。`);const l=r.toVector().normalize(),h=i.toVector().normalize(),d=l.multiply(n).negate(),g=h.multiply(n).negate(),m=e.add(d),y=e.subtract(g);return[new u(t,m),new u(m,y),new u(y,s)]}toObject(){return{start:this.start.toObject(),end:this.end.toObject()}}toObjectXZ(){return{start:this.start.toObjectXZ(),end:this.end.toObjectXZ()}}toArray(){return[this.start.toArray(),this.end.toArray()]}middle(){const t=this.toVector();return this.start.add(t.multiply(.5))}extendOrShrinkFromEnd(t){const e=this.toVector().normalize(),s=this.end.add(e.multiply(t));return new u(this.start,s)}extendOrShrinkFromStart(t){const e=this.toVector().normalize(),s=this.start.subtract(e.multiply(t));return new u(s,this.end)}slope(){const t=this.toVector();return t.x===0?null:t.y/t.x}translate(t){return new u(this.start.add(t),this.end.add(t))}toVector(){return w.fromPoints(this.start,this.end)}angleTo(t){return this.toVector().angleTo(t.toVector())}isParallelTo(t){return this.toVector().isParallelTo(t.toVector())}projectOnto(t){return this.toVector().projectOnto(t.toVector())}lineLineIntersection(t,e=!0){let s=null;const n=this.start,r=this.end,i=t.start,l=t.end,h=r.subtract(n).toVector(),d=l.subtract(i).toVector(),g=i.subtract(n).toVector(),m=h.cross(d);if(m===0)return null;const y=g.cross(d)/m,f=g.cross(h)/m;return(e||y>=0&&y<=1&&f>=0&&f<=1)&&(s=n.add(h.clone().multiply(y))),s}lineArcIntersection(t){const e=[],s=this,n=s.start,r=s.end,i=t.center,l=t.radius,h=r.x-n.x,d=r.y-n.y,g=n.x-i.x,m=n.y-i.y,y=h*h+d*d,f=2*(g*h+m*d),V=g*g+m*m-l*l,b=f*f-4*y*V;if(b<0)return e;const C=Math.sqrt(b),P=(-f+C)/(2*y),E=(-f-C)/(2*y);if(P>=0&&P<=1){const x=new c(n.x+P*h,n.y+P*d);t.isPointOnArc(x)&&e.push(x)}if(E>=0&&E<=1){const x=new c(n.x+E*h,n.y+E*d);t.isPointOnArc(x)&&e.push(x)}return e}toPointsXZ(){return Object.keys(this).forEach(t=>{this[t].constructor===c&&(this[t]=this[t].toPointXZ())}),this}}class ${constructor(t,e,s,n,r,i){o(this,"start");o(this,"end");o(this,"center");o(this,"radius");o(this,"diameter");o(this,"startAngle");o(this,"endAngle");o(this,"startAngleRad");o(this,"endAngleRad");o(this,"angle");o(this,"length");o(this,"direction");o(this,"type");this.start=t,this.end=e,this.center=s,this.radius=n,this.diameter=this.radius*2,this.startAngle=M(r),this.endAngle=M(i),this.startAngleRad=B(r),this.endAngleRad=B(i),this.angle=this.endAngle-this.startAngle,this.length=this.radius*Math.abs(i-r),this.direction=this.angle<0?-1:1,this.type=this.length>=this.radius*O?1:-1}static createArcFromTwoPointAndRadius(t,e,s){const n=this.calculateCircleCenters(t,e,s),r=[];return n.forEach(i=>{const l=i.toVector(t).angleRad(),h=i.toVector(e).angleRad(),g=(h-l<0?-1:1)===-1?l:l+p;r.push(new $(t,e,i,s,g,h),new $(t,e,i,s,g,h+p))}),r}reverse(){return $.createArcFromThreePoints(this.end,this.midpoint(),this.start)}midpoint(){const t=(a(this.startAngle)+a(this.endAngle))/2,e=this.center.x+this.radius*Math.cos(t),s=this.center.y+this.radius*Math.sin(t);return new c(e,s)}extendOrShrinkFromStart(t){const e=this.endAngle-this.startAngle<0?1:-1;return this.startAngle+=e*M(t/this.radius),this.length=this.radius*Math.abs(a(this.endAngle)-a(this.startAngle)),this.start=this.calculatePointOnCircle(a(this.startAngle)),this}extendOrShrinkFromEnd(t){const e=this.endAngle-this.startAngle<0?-1:1;return this.endAngle+=e*M(t/this.radius),this.length=this.radius*Math.abs(a(this.endAngle)-a(this.startAngle)),this.end=this.calculatePointOnCircle(a(this.endAngle)),this}calculatePointOnCircle(t){const e=this.center.x+this.radius*Math.cos(t),s=this.center.y+this.radius*Math.sin(t);return new c(e,s)}static calculateRadiusFromThreePoints(t,e,s){const n=t.distanceTo(e),r=e.distanceTo(s),i=s.distanceTo(t),l=(n+r+i)/2,h=Math.sqrt(l*(l-n)*(l-r)*(l-i));if(h===0)throw new Error(`${this.constructor.name} 三点共线，无法形成圆。`);return n*r*i/(4*h)}static calculateCircleCenters(t,e,s){if(s<=0)throw new Error(`${this.constructor.name} 无效的半径，必须大于零。`);const n=new u(t,e),r=n.length;if(r>2*s)throw new Error(`${this.constructor.name} 无法构造圆：两点间的距离大于直径。`);const i=n.middle(),l=r/2,h=Math.sqrt(s**2-l**2),g=n.toVector().normalize().multiply(h),m=new c(-g.y,g.x),y=i.add(m),f=i.subtract(m);return[y,f]}static createArcFromThreePoints(t,e,s){const n=this.calculateRadiusFromThreePoints(t,e,s),r=this.calculateCircleCenters(t,s,n),i=e.toVector(t),l=s.toVector(e),d=i.angleDirection(l)>0?r[0]:r[1];let g=d.toVector(t).angleRad(),m=d.toVector(s).angleRad();const y=t.toVector(e).angleDirection(e.toVector(s)),V=this.normalizeToMasterCAMAngleRad(g,m,y,-1);return g=V.startAngle,m=V.endAngle,new $(t,s,d,n,g,m)}static createFillet(t,e,s,n){const r=new u(e,t).toVector().normalize(),i=new u(e,s).toVector().normalize(),l=r.angleTo(i);if(l<=0||l>=Math.PI)throw new Error(`${this.constructor.name} 无法创建圆角，夹角必须大于 0 且小于 π。`);const h=l/2,d=n/Math.tan(h),g=n/Math.sin(h),m=r.bisector(i),y=e.add(m.multiply(g)),f=e.add(r.multiply(d)),V=e.add(i.multiply(d));let b=y.toVector(f).angleRad(),C=y.toVector(V).angleRad();const P=t.toVector(e).angleDirection(e.toVector(s)),x=this.normalizeToMasterCAMAngleRad(b,C,P,-1);return b=x.startAngle,C=x.endAngle,new $(f,V,y,n,b,C)}isPointOnArc(t){const e=this.center.toVector(t).angleRad(),s=B(this.startAngle),n=B(this.endAngle),r=B(e);return r>=s&&r<=n}static normalizeToMasterCAMAngleRad(t,e,s=-1,n=-1){let r=e-t;return t<0&&(t+=p),s===-1&&n===-1&&(e<O?e=r+t:e=-p+e),s===1&&e<0&&(e+=p),r=e-t,s=r<0?-1:1,{angle:r,direction:s,startAngle:t,endAngle:e}}static normalizeToMasterCAMAngleDeg(t,e,s=-1,n=-1){let r=e-t;return t<0&&(t+=360),s===-1&&n===-1&&(e<180?e=r+t:e=-360+e),s===1&&e<0&&(e+=360),r=e-t,s=r<0?-1:1,{angle:r,direction:s,startAngle:t,endAngle:e}}toPointsXZ(){return Object.keys(this).forEach(t=>{this[t].constructor===c&&(this[t]=this[t].toPointXZ())}),this}toGcode(){const t=this.start.toPointXZ().toString(),e=this.end.toPointXZ().toString(),s=this.getGcodeDirection(),n=this.type===-1?1:-1,r=this.radius;return{g23r:`G1 ${t}
G${s} ${e} R${Math.abs(r)*n}`,g23ik:`G1 ${t}
G${s} ${e} I${this.center.toVector(this.start).multiply(-1).y} K${this.center.toVector(this.start).multiply(-1).x}`,g1:this.angle===90?"":null}}toSvg(){const t=this.start.toArray().join(" "),e=this.end.toArray().join(" "),s=this.direction==-1?0:1,n=this.type===-1?0:1,r=this.radius;return`path="M ${t} A ${r} ${r} 0 ${n} ${s} ${e}"`}toCanavs(){const t=this.center.toArray().join(", "),e=this.direction==-1?1:0,s=this.radius,n=a(this.startAngle),r=a(this.endAngle);return`ctx.arc(${[t,s,n,r,e].join(", ")});`}toThree(){const t=this.center.toArray().join(", "),e=this.direction==-1?1:0,s=this.radius,n=a(this.startAngle),r=a(this.endAngle);return`new THREE.ArcCurve(${[t,s,n,r,e].join(", ")});`}getGcodeDirection(){return this.direction===-1?2:3}}class D{constructor(t){o(this,"sideA");o(this,"sideB");o(this,"sideC");o(this,"angleA");o(this,"angleB");o(this,"angleC",90);const{sideA:e,sideB:s,sideC:n,angleA:r,angleB:i}=t;if(this.validateInput({sideA:e,sideB:s,sideC:n,angleA:r,angleB:i}),e&&s)this.sideA=e,this.sideB=s,this.sideC=Math.sqrt(e**2+s**2),this.angleA=M(Math.asin(s/this.sideC)),this.angleB=90-this.angleA;else if(e&&n)this.sideA=e,this.sideC=n,this.sideB=Math.sqrt(n**2-e**2),this.angleB=M(Math.asin(e/n)),this.angleA=90-this.angleB;else if(s&&n)this.sideB=s,this.sideC=n,this.sideA=Math.sqrt(n**2-s**2),this.angleA=M(Math.asin(s/n)),this.angleB=90-this.angleA;else if(r&&e)this.angleA=r,this.sideA=e,this.angleB=90-r,this.sideC=e/Math.cos(a(r)),this.sideB=this.sideC*Math.sin(a(r));else if(r&&s)this.angleA=r,this.sideB=s,this.angleB=90-r,this.sideC=s/Math.sin(a(r)),this.sideA=this.sideC*Math.cos(a(r));else if(r&&n)this.angleA=r,this.sideC=n,this.angleB=90-r,this.sideB=n*Math.sin(a(r)),this.sideA=n*Math.cos(a(r));else if(i&&e)this.angleB=i,this.sideA=e,this.angleA=90-i,this.sideC=e/Math.sin(a(i)),this.sideB=this.sideC*Math.cos(a(i));else if(i&&s)this.angleB=i,this.sideB=s,this.angleA=90-i,this.sideC=s/Math.cos(a(i)),this.sideA=this.sideC*Math.sin(a(i));else if(i&&n)this.angleB=i,this.sideC=n,this.angleA=90-i,this.sideA=n*Math.sin(a(i)),this.sideB=n*Math.cos(a(i));else throw new Error(`${this.constructor.name} Invalid input combination.`);this.validatePythagoras(),this.validateAngles()}validateInput(t){if(Object.values(t).filter(s=>s!==void 0).length<2)throw new Error(`${this.constructor.name} At least two values must be provided.`)}validateAngles(){if(this.angleA&&this.angleB&&Math.abs(this.angleA+this.angleB-90)>1e-4)throw new Error(`${this.constructor.name} The sum of angleA and angleB must be 90 degrees.`)}validatePythagoras(){if(this.sideA&&this.sideB&&this.sideC&&Math.abs(this.sideA**2+this.sideB**2-this.sideC**2)>1e-4)throw new Error(`${this.constructor.name} The lengths do not satisfy the Pythagorean theorem.`)}toPoint(){if(this.sideA&&this.sideB)return c.fromObjectXZ({x:this.sideA*2,z:this.sideB})}}export{$ as A,u as L,c as P,D as R,z as a};
