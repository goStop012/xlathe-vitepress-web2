var O=Object.defineProperty;var B=(d,t,e)=>t in d?O(d,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):d[t]=e;var h=(d,t,e)=>B(d,typeof t!="symbol"?t+"":t,e);const E=Math.PI,M=2*E;var T=(d=>(d[d.NonDirection=0]="NonDirection",d[d.Clockwise=-1]="Clockwise",d[d.CounterClockwise=1]="CounterClockwise",d))(T||{}),S=(d=>(d[d.Minor=-1]="Minor",d[d.Major=1]="Major",d))(S||{});function m(d){return d*(Math.PI/180)}function p(d){return d*(180/Math.PI)}function R(d){return(d%M+M)%M}class P{constructor(t,e){h(this,"x");h(this,"z");this.x=t,this.z=e}static fromArray(t){if(t.length!==2)throw new Error(`${this.constructor.name} Array must contain exactly two elements: [x, z]`);return new P(t[0],t[1])}static fromObject(t){if(typeof t.x!="number"||typeof t.z!="number")throw new Error(`${this.constructor.name} Object must have numeric properties x and z`);return new P(t.x,t.z)}toPoint(){return new u(this.z,this.x/2)}toString(){return`X${this.x} Z${this.z}`}}class u{constructor(t,e){h(this,"x");h(this,"y");this.x=t,this.y=e}static fromArray(t){if(t.length!==2)throw new Error(`${this.constructor.name} Array must contain exactly two elements: [x, y]`);return new u(t[0],t[1])}static fromArrayXZ(t){if(t.length!==2)throw new Error(`${this.constructor.name} Array must contain exactly two elements: [x, z]`);return new u(t[1],t[0]/2)}static fromObject(t){if(typeof t.x!="number"||typeof t.y!="number")throw new Error(`${this.constructor.name} Object must have numeric properties x and y`);return new u(t.x,t.y)}static fromObjectXZ(t){if(typeof t.x!="number"||typeof t.z!="number")throw new Error(`${this.constructor.name} Object must have numeric properties x and z`);return new u(t.z,t.x/2)}isZero(){return this.x===0&&this.y===0}toVector(t){return t instanceof u?new y(t.x-this.x,t.y-this.y):new y(this.x,this.y)}mirror(t){const e=t.normalize().perpendicular();return this.toVector().reflect(e).toPoint()}toObjectXZ(){return{x:this.y*2,z:this.x}}toObject(){return{x:this.x,y:this.y}}toArray(){return[this.x,this.y]}toPointXZ(){return P.fromObject(this.toObjectXZ())}add(t){return new u(this.x+t.x,this.y+t.y)}subtract(t){return new u(this.x-t.x,this.y-t.y)}multiply(t){return new u(this.x*t,this.y*t)}divide(t){if(t===0)throw new Error(`${this.constructor.name} - Division by zero`);return new u(this.x/t,this.y/t)}clone(){return new u(this.x,this.y)}equals(t){return this.x===t.x&&this.y===t.y}distanceTo(t){return this.toVector(t).length()}}class y extends u{constructor(t,e){super(t,e)}static fromPoints(t,e){return new y(e.x-t.x,e.y-t.y)}toPoint(){return new u(this.x,this.y)}length(){return Math.sqrt(this.x**2+this.y**2)}normalize(){const t=this.length();if(t===0)throw new Error(`${this.constructor.name} - Cannot normalize a zero vector`);return new y(this.x/t,this.y/t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}angleTo(t){const e=this.dot(t),s=this.length()*t.length();if(s===0)throw new Error(`${this.constructor.name} - Cannot calculate angle with zero-length vector`);const n=e/s,r=this.angleDirection(t);return Math.acos(Math.min(Math.max(n,-1),1))*(r<0?-1:1)}rotate(t){const e=Math.cos(t),s=Math.sin(t),n=this.x*e-this.y*s,r=this.x*s+this.y*e;return new y(n,r)}projectOnto(t){const e=this.dot(t)/t.length()**2;return t.multiply(e)}lerp(t,e){const s=this.x+e*(t.x-this.x),n=this.y+e*(t.y-this.y);return new y(s,n)}distanceTo(t){return Math.sqrt((this.x-t.x)**2+(this.y-t.y)**2)}isZero(){return this.x===0&&this.y===0}perpendicular(){return new y(-this.y,this.x)}reflect(t){const e=this.dot(t);return this.subtract(t.multiply(2*e))}angleDirection(t){const e=this.cross(t);return e>0?1:e<0?-1:0}bisector(t){return this.add(t).normalize()}clampLength(t){return this.length()>t?this.normalize().multiply(t):this}negate(){return new y(-this.x,-this.y)}isParallelTo(t){return this.cross(t)===0}translate(t){return this.add(t)}increaseLength(t){const e=this.length();if(e===0)throw new Error(`${this.constructor.name} - Cannot increase length of a zero vector`);const s=(e+t)/e;return this.multiply(s)}decreaseLength(t){const e=this.length();if(t>=e)return new y(0,0);const s=(e-t)/e;return this.multiply(s)}angleRad(){return Math.atan2(this.y,this.x)}angle(){return p(Math.atan2(this.y,this.x))}arrowDirection(){return this.angleRad()===Math.PI/2?"↑":this.angleRad()===3*Math.PI/2?"↓":this.angleRad()===0?"→":this.angleRad()===Math.PI?"←":this.x>0&&this.y<0?"↘":this.x<0&&this.y<0?"↙":this.x>0&&this.y>0?"↗":this.x<0&&this.y>0?"↖":"null"}clone(){return new y(this.x,this.y)}equals(t){return super.equals(t)}add(t){return super.add(t).toVector()}subtract(t){return super.subtract(t).toVector()}multiply(t){return super.multiply(t).toVector()}divide(t){return super.divide(t).toVector()}}class f{constructor(t,e){h(this,"start");h(this,"end");h(this,"length");h(this,"angle");h(this,"angleRad");h(this,"vector");h(this,"delta");h(this,"arrowDirection");this.start=t,this.end=e,this.vector=this.toVector(),this.delta=y.fromPoints(e,t),this.length=this.vector.length(),this.angle=this.vector.angle(),this.angleRad=this.vector.angleRad(),this.arrowDirection=this.vector.arrowDirection()}static fromArray(t){if(t.length!==2)throw new Error(`${this.constructor.name} 数组必须包含两个点坐标`);const[e,s]=t;return new f(u.fromArray(e),u.fromArray(s))}static fromArrayXZ(t){if(t.length!==2)throw new Error(`${this.constructor.name} 数组必须包含两个点坐标`);const[e,s]=t;return new f(u.fromArrayXZ(e),u.fromArrayXZ(s))}static fromNumber(t,e,s,n){return f.fromArray([[t,e],[s,n]])}static fromNumberXZ(t,e,s,n){return f.fromArray([[e,t/2],[n,s/2]])}static createLineFromAngle(t,e,s){if([...t.toArray(),...e.toArray(),s].filter(isFinite).length<4||!isFinite(s))throw new Error(`${this.constructor.name} 有效参数不够，无法进行计算。`);const i=Math.tan(m(s));return isFinite(t.x)?isFinite(t.y)?isFinite(e.x)?isFinite(e.y)||(e.y=t.y+(e.x-t.x)*i):e.x=t.x+(e.y-t.y)/i:t.y=e.y-(e.x-t.x)*i:t.x=e.x-(e.y-t.y)/i,new f(t,e)}static createLineFromLengthAndAngle(t,e,s){const n=m(s),r=new y(Math.cos(n),Math.sin(n)),i=t.add(r.multiply(e*(s>0&&s<180?-1:1)));return new f(t,i)}static createHorizontallLine(t,e){return new f(t,new u(t.x,e))}static createVerticalLine(t,e){return new f(t,new u(e,t.y))}static createHorizontallLineXZ(t,e){return new f(t.toPoint(),new P(e,t.z).toPoint())}static createVerticalLineXZ(t,e){return new f(t.toPoint(),new P(t.x,e).toPoint())}reverse(){return new f(this.end,this.start)}static createFillet(t,e,s,n){const r=new f(t,e),i=new f(e,s);if(r.length<n||i.length<n)throw new Error(`${this.constructor.name} 长度不够，无法进行倒角。`);const l=r.toVector().normalize(),a=i.toVector().normalize(),g=l.multiply(n).negate(),c=a.multiply(n).negate(),o=e.add(g),w=e.subtract(c);return[new f(t,o),new f(o,w),new f(w,s)]}toObject(){return{start:this.start.toObject(),end:this.end.toObject()}}toObjectXZ(){return{start:this.start.toObjectXZ(),end:this.end.toObjectXZ()}}toArray(){return[this.start.toArray(),this.end.toArray()]}middle(){const t=this.toVector();return this.start.add(t.multiply(.5))}extendOrShrinkFromEnd(t){const e=this.toVector().normalize(),s=this.end.add(e.multiply(t));return new f(this.start,s)}extendOrShrinkFromStart(t){const e=this.toVector().normalize(),s=this.start.subtract(e.multiply(t));return new f(s,this.end)}slope(){const t=this.toVector();return t.x===0?null:t.y/t.x}translate(t){return new f(this.start.add(t),this.end.add(t))}toVector(){return y.fromPoints(this.start,this.end)}angleTo(t){return this.toVector().angleTo(t.toVector())}isParallelTo(t){return this.toVector().isParallelTo(t.toVector())}projectOnto(t){return this.toVector().projectOnto(t.toVector())}lineLineIntersection(t,e=!0){let s=null;const n=this.start,r=this.end,i=t.start,l=t.end,a=r.subtract(n).toVector(),g=l.subtract(i).toVector(),c=i.subtract(n).toVector(),o=a.cross(g);if(o===0)return null;const w=c.cross(g)/o,A=c.cross(a)/o;return(e||w>=0&&w<=1&&A>=0&&A<=1)&&(s=n.add(a.clone().multiply(w))),s}lineArcIntersection(t){const e=[],s=this,n=s.start,r=s.end,i=t.center,l=t.radius,a=r.x-n.x,g=r.y-n.y,c=n.x-i.x,o=n.y-i.y,w=a*a+g*g,A=2*(c*a+o*g),v=c*c+o*o-l*l,b=A*A-4*w*v;if(b<0)return e;const z=Math.sqrt(b),C=(-A+z)/(2*w),$=(-A-z)/(2*w);if(C>=0&&C<=1){const V=new u(n.x+C*a,n.y+C*g);t.isPointOnArc(V)&&e.push(V)}if($>=0&&$<=1){const V=new u(n.x+$*a,n.y+$*g);t.isPointOnArc(V)&&e.push(V)}return e}toPointsXZ(){return Object.keys(this).forEach(t=>{this[t].constructor===u&&(this[t]=this[t].toPointXZ())}),this}}class x{constructor(t,e,s,n,r,i){h(this,"start");h(this,"end");h(this,"center");h(this,"radius");h(this,"diameter");h(this,"startAngle");h(this,"endAngle");h(this,"startAngleRad");h(this,"endAngleRad");h(this,"angle");h(this,"length");h(this,"direction");h(this,"type");this.start=t,this.end=e,this.center=s,this.radius=n,this.diameter=this.radius*2,this.startAngle=p(r),this.endAngle=p(i),this.startAngleRad=r,this.endAngleRad=i,this.angle=this.endAngle-this.startAngle,this.length=this.radius*Math.abs(this.endAngleRad-this.startAngleRad),this.direction=this.angle<0?-1:1,this.type=this.length>=this.radius*E?1:-1}static createArcFromTwoPointAndRadius(t,e,s){const n=this.calculateCircleCenters(t,e,s),r=[];return n.forEach(i=>{let l=i.toVector(t).angleRad(),a=i.toVector(e).angleRad();[l,a]=x.normalizeArcAngle(l,a);const g=new x(t,e,i,s,l,a);r.push(g,g.complementary().reverseDirection())}),r}reverse(){return x.createArcFromThreePoints(this.end,this.midpoint(),this.start)}mirror(t,e=this){const s=e.center.mirror(t),n=e.start.mirror(t),r=e.end.mirror(t),i=e.direction,l=i===1?1:0;let a=s.toVector(n).angleRad()+Math.PI*2*l,g=s.toVector(r).angleRad();const c=g-a;Math.abs(c)>=Math.PI&&i===-1&&(a+=Math.PI*2,g+=Math.PI*2);const o=e.radius;return new x(n,r,s,o,a,g)}complementary(t=this){const e=Math.PI*2,{endAngleRad:s,startAngleRad:n}=t,r=s-n,i=Math.sign(r),l=(e-Math.abs(r))*i,a=s==0?e:s,g=a+l;let c=[a,g];return c.every(o=>o<0)&&(c=c.map(o=>o+e)),c.every(o=>o>=e)&&(c=c.map(o=>o%e)),new x(t.start,t.end,t.center,t.radius,c[0],c[1])}reverseDirection(t=this){const e=Math.PI*2,{endAngleRad:s,startAngleRad:n}=t,r=s-n,l=Math.sign(r)*-1;let c=[s,n];return c.some(o=>o<0||o>e)&&(c=c.map(o=>o+e*l)),c.some(o=>o>=2*e)&&(c=c.map(o=>o%e).map(o=>o===0?e:o)),new x(t.start,t.end,t.center,t.radius,c[0],c[1])}static normalizeArcAngle(t,e){const s=Math.PI*2;let n=[t,e];return n=n.map(r=>r<0?r+s:r),n}midpoint(){const t=(m(this.startAngle)+m(this.endAngle))/2,e=this.center.x+this.radius*Math.cos(t),s=this.center.y+this.radius*Math.sin(t);return new u(e,s)}extendOrShrinkFromStart(t){const e=this.endAngle-this.startAngle<0?1:-1;return this.startAngle+=e*p(t/this.radius),this.length=this.radius*Math.abs(m(this.endAngle)-m(this.startAngle)),this.start=this.calculatePointOnCircle(m(this.startAngle)),this}extendOrShrinkFromEnd(t){const e=this.endAngle-this.startAngle<0?-1:1;return this.endAngle+=e*p(t/this.radius),this.length=this.radius*Math.abs(m(this.endAngle)-m(this.startAngle)),this.end=this.calculatePointOnCircle(m(this.endAngle)),this}calculatePointOnCircle(t){const e=this.center.x+this.radius*Math.cos(t),s=this.center.y+this.radius*Math.sin(t);return new u(e,s)}static calculateRadiusFromThreePoints(t,e,s){const n=t.distanceTo(e),r=e.distanceTo(s),i=s.distanceTo(t),l=(n+r+i)/2,a=Math.sqrt(l*(l-n)*(l-r)*(l-i));if(a===0)throw new Error(`${this.constructor.name} 三点共线，无法形成圆。`);return n*r*i/(4*a)}static calculateCircleCenters(t,e,s){if(s<=0)throw new Error(`${this.constructor.name} 无效的半径，必须大于零。`);const n=new f(t,e),r=n.length;if(r>2*s)throw new Error(`${this.constructor.name} 无法构造圆：两点间的距离大于直径。`);const i=n.middle(),l=r/2,a=Math.sqrt(s**2-l**2),g=n.toVector().normalize(),o=new y(-g.y,g.x).multiply(a),w=i.add(o),A=i.subtract(o);return[w,A]}static createArcFromThreePoints(t,e,s){const n=this.calculateRadiusFromThreePoints(t,e,s),r=this.createArcFromTwoPointAndRadius(t,s,n),i=-1,l=t.toVector(e).angleDirection(e.toVector(s));return x.find(r,i,l)}static createFillet(t,e,s,n){const r=new f(e,t).toVector().normalize(),i=new f(e,s).toVector().normalize(),l=r.angleTo(i),a=Math.sign(l),g=l/2,c=n/Math.tan(g),o=e.add(r.multiply(c).multiply(a)),w=e.add(i.multiply(c).multiply(a)),A=this.createArcFromTwoPointAndRadius(o,w,n),v=-1,b=t.toVector(e).angleDirection(e.toVector(s));return x.find(A,v,b)}static find(t,e,s){return t.find(n=>n.type===e&&n.direction===s)}isPointOnArc(t){const e=this.center.toVector(t).angleRad(),s=R(this.startAngle),n=R(this.endAngle),r=R(e);return r>=s&&r<=n}static normalizeToMasterCAMAngleRad(t,e,s=-1,n=-1){let r=e-t;return t<0&&(t+=M),s===-1&&n===-1&&(e<E?e=r+t:e=-M+e),s===1&&e<0&&(e+=M),r=e-t,s=r<0?-1:1,{angle:r,direction:s,startAngle:t,endAngle:e}}static normalizeToMasterCAMAngleDeg(t,e,s=-1,n=-1){let r=e-t;return t<0&&(t+=360),s===-1&&n===-1&&(e<180?e=r+t:e=-360+e),s===1&&e<0&&(e+=360),r=e-t,s=r<0?-1:1,{angle:r,direction:s,startAngle:t,endAngle:e}}toPointsXZ(){return Object.keys(this).forEach(t=>{this[t].constructor===u&&(this[t]=this[t].toPointXZ())}),this}toGcode(){const t=this.start.toPointXZ().toString(),e=this.end.toPointXZ().toString(),s=this.getGcodeDirection(),n=this.type===-1?1:-1,r=this.radius;return{g23r:`G1 ${t}
G${s} ${e} R${Math.abs(r)*n}`,g23ik:`G1 ${t}
G${s} ${e} I${this.center.toVector(this.start).multiply(-1).y} K${this.center.toVector(this.start).multiply(-1).x}`,g1:this.angle===90?"":null}}toSvg(){const t=this.start.toArray().join(" "),e=this.end.toArray().join(" "),s=this.direction==-1?0:1,n=this.type===-1?0:1,r=this.radius;return`path="M ${t} A ${r} ${r} 0 ${n} ${s} ${e}"`}toCanavs(){const t=this.center.toArray().join(", "),e=this.direction==-1?1:0,s=this.radius,n=m(this.startAngle),r=m(this.endAngle);return`ctx.arc(${[t,s,n,r,e].join(", ")});`}toThree(){const t=this.center.toArray().join(", "),e=this.direction==-1?1:0,s=this.radius,n=m(this.startAngle),r=m(this.endAngle);return`new THREE.ArcCurve(${[t,s,n,r,e].join(", ")});`}getGcodeDirection(){return this.direction===-1?2:3}}class F{constructor(t){h(this,"sideA");h(this,"sideB");h(this,"sideC");h(this,"angleA");h(this,"angleB");h(this,"angleC",90);const{sideA:e,sideB:s,sideC:n,angleA:r,angleB:i}=t;if(this.validateInput({sideA:e,sideB:s,sideC:n,angleA:r,angleB:i}),e&&s)this.sideA=e,this.sideB=s,this.sideC=Math.sqrt(e**2+s**2),this.angleA=p(Math.asin(s/this.sideC)),this.angleB=90-this.angleA;else if(e&&n)this.sideA=e,this.sideC=n,this.sideB=Math.sqrt(n**2-e**2),this.angleB=p(Math.asin(e/n)),this.angleA=90-this.angleB;else if(s&&n)this.sideB=s,this.sideC=n,this.sideA=Math.sqrt(n**2-s**2),this.angleA=p(Math.asin(s/n)),this.angleB=90-this.angleA;else if(r&&e)this.angleA=r,this.sideA=e,this.angleB=90-r,this.sideC=e/Math.cos(m(r)),this.sideB=this.sideC*Math.sin(m(r));else if(r&&s)this.angleA=r,this.sideB=s,this.angleB=90-r,this.sideC=s/Math.sin(m(r)),this.sideA=this.sideC*Math.cos(m(r));else if(r&&n)this.angleA=r,this.sideC=n,this.angleB=90-r,this.sideB=n*Math.sin(m(r)),this.sideA=n*Math.cos(m(r));else if(i&&e)this.angleB=i,this.sideA=e,this.angleA=90-i,this.sideC=e/Math.sin(m(i)),this.sideB=this.sideC*Math.cos(m(i));else if(i&&s)this.angleB=i,this.sideB=s,this.angleA=90-i,this.sideC=s/Math.cos(m(i)),this.sideA=this.sideC*Math.sin(m(i));else if(i&&n)this.angleB=i,this.sideC=n,this.angleA=90-i,this.sideA=n*Math.sin(m(i)),this.sideB=n*Math.cos(m(i));else throw new Error(`${this.constructor.name} Invalid input combination.`);this.validatePythagoras(),this.validateAngles()}validateInput(t){if(Object.values(t).filter(s=>s!==void 0).length<2)throw new Error(`${this.constructor.name} At least two values must be provided.`)}validateAngles(){if(this.angleA&&this.angleB&&Math.abs(this.angleA+this.angleB-90)>1e-4)throw new Error(`${this.constructor.name} The sum of angleA and angleB must be 90 degrees.`)}validatePythagoras(){if(this.sideA&&this.sideB&&this.sideC&&Math.abs(this.sideA**2+this.sideB**2-this.sideC**2)>1e-4)throw new Error(`${this.constructor.name} The lengths do not satisfy the Pythagorean theorem.`)}toPoint(){if(this.sideA&&this.sideB)return u.fromObjectXZ({x:this.sideA*2,z:this.sideB})}}export{x as A,f as L,u as P,F as R,T as a,S as b,P as c};
